#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2008, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Revision $Id: rosdoc 11469 2010-10-12 00:56:25Z kwc $

import rosdoc_lite
import urllib
import os
import sys
import yaml
import subprocess
from common import *
from tags_db import *

def get_stack_packages(stack_folder):
    packages = []

    #Handle the case of a unary stack
    if os.path.isfile(os.path.join(stack_folder, 'manifest.xml')):
        packages.append(os.path.basename(stack_folder))
        #At this point, we don't need to search through subdirectories
        return packages

    #Get a list of all the directories in the stack folder
    #A folder is defined as a package if it contains a manifest.xml file
    print "Getting the packages that are a part of a given stack %s..." % stack_folder
    subdirs = [name for name in os.listdir(stack_folder) if os.path.isdir(os.path.join(stack_folder, name))]
    for subdir in subdirs:
        if os.path.isfile(os.path.join(stack_folder, subdir, 'manifest.xml')):
            packages.append(os.path.basename(subdir))
    return packages

def call(command, envir=None):
    print "Executing command '%s'"%command
    helper = subprocess.Popen(command.split(' '), stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True, env=envir)
    res, err = helper.communicate()
    print str(res)
    print str(err)
    if helper.returncode != 0:
        msg = "Failed to execute command '%s'"%command
        print "/!\  %s"%msg
        raise BuildException(msg)
    return res

def build_tagfile(apt_deps, tags_db, rosdoc_tagfile, current_deb, current_package):
    #Get the relevant tags from the database
    apt_tags = tags_db.get_stack_tags(apt_deps)
    tags = []

    if apt_tags:
        for dep in apt_deps:
            if dep in apt_tags:
                #Make sure that we don't pass our own tagfile to ourself
                #bad things happen when we do this, we only need to perform
                #this check for our dep
                if dep == current_deb:
                    for tag in apt_tags[dep]:
                        if tag['package'] != current_package:
                            tags.append(tag)
                else:
                    tags.extend(apt_tags[dep])

    tags_file = file(rosdoc_tagfile, 'w')
    yaml.dump(tags, tags_file)

#As far as I know, the best way to check whether a stack is catkinized or not is to 
#download the current rosdistro for catkin and see if the name is in the rosdistro file
def is_catkin_stack(stack_name, ros_distro):
    f = urllib.urlopen('https://raw.github.com/ros/rosdistro/master/releases/%s.yaml'%ros_distro)
    catkin_repos = yaml.load(f.read())['repositories']
    return stack_name in catkin_repos

def get_stack_deb_name(stack_name, catkin_stack, ros_distro):
    if not catkin_stack:
        # Replacing underscores with dashes may not be sufficient, but I think
        # it is for the old deb stuff
        return "ros-%s-%s" % (ros_distro, stack_name.replace('_', '-'))
    else:
        ros_dep = RosDep(ros_distro)
        return ros_dep.to_apt(stack_name)

def document_stack(workspace, docspace, ros_distro, stack):
    print "Working on distro %s and stack %s" % (ros_distro, stack)
    print "Parsing doc file for %s" % ros_distro
    f = urllib.urlopen('https://raw.github.com/eitanme/rosdistro/master/releases/%s-doc.yaml'%ros_distro)
    repos = yaml.load(f.read())['repositories']

    print "Finding information for stack %s" % stack
    if not stack in repos.keys():
        raise Exception("Stack %s does not exist in %s rosdistro file" % (stack, ros_distro))

    conf = repos[stack]
    rosinstall = yaml.dump([{conf['type']: {'local-name': stack, 'uri': conf['url'], 'version': conf['version']}}], default_style=False)
    print "Rosinstall for stack %s:\n%s"%(stack, rosinstall)
    with open(workspace+"/stack.rosinstall", 'w') as f:
        f.write(rosinstall)
    print "Created rosinstall file for stack %s, installing stack..."%stack
    #TODO Figure out why rosinstall insists on having ROS available when called with nobuild, but not catkin
    call("rosinstall %s %s/stack.rosinstall --nobuild --catkin" % (docspace, workspace))

    stack_path = os.path.abspath("%s/%s" % (docspace, stack))
    print "Stack path %s" % stack_path
    packages = get_stack_packages(stack_path)
    print "Running documentation generation on packages %s" % packages

    #Check whether we're using a catkin stack or not
    catkin_stack = is_catkin_stack(stack, ros_distro)

    #Get the apt name of the current stack
    deb_name = get_stack_deb_name(stack, catkin_stack, ros_distro)

    #TODO: Replace with OS_PLATFORM, OS_ARCH
    apt = AptDepends('precise', 'amd64')
    apt_deps = apt.depends(deb_name)
    apt_deps.append(deb_name)

    #TODO: Real database name
    tags_db = TagsDb('test.db', ros_distro)

    stack_tags = []
    for package in packages:
        #Build a tagfile list from dependencies for use by rosdoc
        build_tagfile(apt_deps, tags_db, 'rosdoc_tags.yaml', deb_name, package)

        html_path = os.path.abspath("%s/doc/%s/api/%s/html" % (docspace, ros_distro, package))
        #tags_path = os.path.abspath("%s/docs/tags/%s.tag" % (docspace, package))
        tags_path = os.path.abspath("%s/doc/%s/api/%s/tags/%s.tag" % (docspace, ros_distro, package, package))
        print "Documenting %s..." % package
        #TODO remove local sourcing stuff in favor of deb installs
        command = ['bash', '-c', 'source /opt/ros/%s/setup.bash \
                   && source /home/eitan/local_installs/setup.bash \
                   && export ROS_PACKAGE_PATH=%s:$ROS_PACKAGE_PATH \
                   && rosdoc_lite %s -o %s -g %s -t rosdoc_tags.yaml -q' \
                   %(ros_distro, stack_path, package, html_path, tags_path) ]
        proc = subprocess.Popen(command, stdout=subprocess.PIPE)
        proc.communicate()
        #TODO: Fill in a reasonable docs url
        stack_tags.append({'location':'file://%s'%tags_path, 
                               'docs_url':'http://www.ros.org/doc/%s/api/%s/html'%(ros_distro, package), 
                               'package':'%s'%package})
        print "Done"

    #Write the new tags to the database
    tags_db.write_stack_tags(deb_name, stack_tags)

def main():
    arguments = sys.argv[1:]
    ros_distro = arguments[0]
    stack = arguments[1]
    workspace = 'workspace'
    docspace = 'docspace'
    document_stack(workspace, docspace, ros_distro, stack)


if __name__ == '__main__':
    main()
