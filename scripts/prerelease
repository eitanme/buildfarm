#!/usr/bin/env python
import os
import sys
import rosdistro
import yaml
import subprocess
import urllib
import string
import datetime
import fnmatch
from xml.etree.ElementTree import ElementTree


class AptDepends:
    def __init__(self, ubuntudistro, arch):
        url = urllib.urlopen('http://packages.ros.org/ros-shadow-fixed/ubuntu/dists/%s/main/binary-%s/Packages'%(ubuntudistro, arch))
        self.dep = {}
        package = None
        for l in url.read().split('\n'):
            if 'Package: ' in l:
                package = l.split('Package: ')[1]
            if 'Depends: ' in l:
                if not package:
                    raise BuildException("Found 'depends' but not 'package' while parsing the apt repository index file")
                self.dep[package] = [d.split(' ')[0] for d in (l.split('Depends: ')[1].split(', '))]
                package = None
        
    def depends1(self, package):
        return self.depends(package, one=True)

    def depends(self, package, res=[], one=False):
        if package in self.dep:
            for d in self.dep[package]:
                if not d in res:
                    res.append(d)
                if not one:
                    self.depends(d, res, one)
        return res
            
    def depends_on1(self, package):
        return self.depends_on(package, one=True)

    def depends_on(self, package, res=[], one=False):
        for p, dep in self.dep.iteritems():
            if package in dep:
                if not p in res:
                    res.append(p)
                if not one:
                    self.depends_on(p, res, one)
        return res
        



class RosDep:
    def __init__(self, ros_distro):
        self.r2a = {}
        self.a2r = {}
        self.env = os.environ
        self.env['ROS_DISTRO'] = ros_distro

        # Initialize rosdep database
        print "Ininitalize rosdep database"
        call("apt-get install --yes lsb-release python-rosdep")
        call("rosdep init", self.env)
        call("rosdep update", self.env)

    def to_apt(self, r):
        if r in self.r2a:
            return self.r2a[r]
        else:
            a = call("rosdep resolve %s"%r, self.env).split('\n')[1]
            print "Rosdep %s resolved into %s"%(r, a)
            self.r2a[r] = a
            self.a2r[a] = r
            return a

    def to_stack(self, a):
        if not a in self.a2r:
            print "%s not in apt-to-rosdep cache"%a
        return self.a2r[a]



def get_ros_env(setup_file):
    ros_env = os.environ
    print "Retrieve the ROS build environment by sourcing %s"%setup_file
    command = ['bash', '-c', 'source %s && env'%setup_file]
    proc = subprocess.Popen(command, stdout = subprocess.PIPE)
    for line in proc.stdout:
        (key, _, value) = line.partition("=")
        ros_env[key] = value.split('\n')[0]
    proc.communicate()
    if proc.returncode != 0:
        msg = "Failed to source %s"%setup_file
        print "/!\  %s"%msg
        raise BuildException(msg)
    print "ROS environment: %s"%str(ros_env)
    return ros_env


def call(command, envir=None):
    print "Executing command '%s'"%command
    helper = subprocess.Popen(command.split(' '), stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True, env=envir)
    res, err = helper.communicate()
    print str(res)
    print str(err)
    if helper.returncode != 0:
        msg = "Failed to execute command '%s'"%command
        print "/!\  %s"%msg
        raise BuildException(msg)
    return res


def get_dependencies(stack_folder):
    # get the stack dependencies
    print "Get the dependencies of stack in folder %s"%stack_folder
    try:
        print "Parsing stack.xml..."
        root = ElementTree(None, os.path.join(stack_folder, 'stack.xml'))
        stack_dependencies = [d.text for d in root.findall('depends')]
        system_dependencies = [d.text for d in root.findall('build_depends')]
        print "Stack Dependencies: %s"%(' '.join(stack_dependencies))
        print "System Dependencies: %s"%(' '.join(system_dependencies))
        return stack_dependencies + system_dependencies
    except Exception, ex:
        raise BuildException("Failed to parse stack.xml of stack in folder %s"%stack_folder)


def copy_test_results(workspace, buildspace):
    print "Preparing xml test results"
    try:
        os.makedirs(os.path.join(workspace, 'test_results'))
        print "Created test results directory"
    except:
        pass
    os.chdir(os.path.join(workspace, 'test_results'))
    print "Copy all test results"
    count = 0
    for root, dirnames, filenames in os.walk(os.path.join(buildspace, 'test_results')):
        for filename in fnmatch.filter(filenames, '*.xml'):
            call("cp %s %s/test_results/"%(os.path.join(root, filename), workspace))
            count += 1
    if count == 0:
        print "No test results, so I'll create a dummy test result xml file"
        call("cp %s %s"%(os.path.join(workspace, 'buildfarm/templates/junit_dummy_ouput_template.xml'),
                         os.path.join(workspace, 'test_results/')))

    
class BuildException(Exception):
    def __init__(self, msg):
        self.msg = msg




def main():

    if len(sys.argv) <= 2:
        print "Usage: %s ros_distro stack_name"%sys.argv[0]
        raise BuildException("Wrong number of parameters for prerelase script")
    else:
        ros_distro = sys.argv[1]
        stacks = sys.argv[2:]
        print "Working on distro %s and stacks %s"%(ros_distro, ', '.join(stacks))

    workspace = os.environ['WORKSPACE']
    sourcespace = os.path.join('%s/tmp'%workspace, str(datetime.datetime.now()).replace(' ','_').replace(':','.'))
    stackbuildspace = os.path.join(sourcespace, 'build_stack')
    dependbuildspace = os.path.join(sourcespace, 'build_depend_on')
    os.makedirs(sourcespace)

    # Add ros to apt
    print "Add ros to apt sources"
    with open('/etc/apt/sources.list.d/ros-latest.list', 'w') as f:
        f.write("deb http://packages.ros.org/ros-shadow-fixed/ubuntu %s main"%os.environ['OS_PLATFORM'])
    call("wget http://packages.ros.org/ros.key -O %s/ros.key"%workspace)
    call("apt-key add %s/ros.key"%workspace)
    call("apt-get update")

    # install vcs tools
    print "Installing vcs tools"
    call("apt-get install mercurial subversion --yes")

    # Create rosdep object
    print "Create rosdep object"
    rosdep = RosDep(ros_distro)
    stacks_apt = [rosdep.to_apt(s) for s in stacks]

    # parse the rosdistro file
    print "Parsing rosdistro file for %s"%ros_distro
    distro = rosdistro.Rosdistro(ros_distro)
    print "Resolve all entries in the rosdistro file to ros packages"
    distro_apt = []
    for d in distro._repoinfo.keys():
        distro_apt.append(rosdep.to_apt(d))

    # download the stacks from source
    print "Downloading all stacks"
    rosinstall = ""
    for stack in stacks:
        print "Finding repo for stack %s"%stack
        if not stack in distro._repoinfo.keys():
            raise BuildException("Stack %s does not exist in Rosdistro"%stack)
        ri= yaml.dump([{'git': {'local-name': stack, 'uri': distro._repoinfo[stack].url, 'version': 'master'}}], default_style=False)
        print "Rosinstall for stack %s:\n %s"%(stack, ri)
        rosinstall += ri
    with open(workspace+"/stack.rosinstall", 'w') as f:
        f.write(rosinstall)
    print "Create rosinstall file for stacks %s"%(', '.join(stacks))
    call("rosinstall %s %s/stack.rosinstall --catkin"%(sourcespace, workspace))

    # get the stack dependencies
    print "Get all stack dependencies"
    catkin = True
    dependencies = []
    for stack in stacks:
        dep = get_dependencies(os.path.join(sourcespace, stack))
        if not 'catkin' in dep:
            catkin = False
        for d in dep:
            if not d in dependencies and not d in stacks:
                dependencies.append(d)
    if len(dependencies) > 0:
        print "Install all dependencies of stacks: %s"%(', '.join(dependencies))
        call("apt-get install %s --yes"%(' '.join([rosdep.to_apt(r) for r in dependencies])))

    # check
    if not catkin and len(stacks) > 1:
        raise BuildException("Can only test one non-catkin stack at a time")

    # replace the CMakeLists.txt file for stacks that use catkin
    print "Removing the CMakeLists.txt file generated by rosinstall"
    os.remove(os.path.join(sourcespace, 'CMakeLists.txt'))
    os.makedirs(stackbuildspace)
    os.chdir(stackbuildspace)
    if catkin:
        print "Create a new CMakeLists.txt file using catkin"
        ros_env = get_ros_env('/opt/ros/%s/setup.bash'%ros_distro)
        call("catkin_init_workspace %s"%sourcespace, ros_env)
        call("cmake ..", ros_env)        
        ros_env = get_ros_env(os.path.join(stackbuildspace, 'buildspace/setup.bash'))
    else:
        print "Use the CMakeLists.txt file from the stack itself"
        ros_env = os.environ
        call("cmake ../%s"%stack, ros_env)


    # build stacks
    print "Build stacks"
    call("make", ros_env)
    print "Test stacks"
    call("make run_tests", ros_env)

    # don't test depends-on for non-catkin stacks
    if not catkin:
        copy_test_results(workspace, stackbuildspace)
        print "We're not testing the depends-on for non-catkin stacks"
        return

    # get stack depends-on list
    print "Get list of stacks that depend on %s"%stack
    apt = AptDepends(os.environ['OS_PLATFORM'], os.environ['ARCH'])
    depends_on_apt = []
    depends_on = []
    for stack_apt in stacks_apt:
        for d in apt.depends_on(stack_apt):
            if not d in depends_on_apt and not d in stacks_apt and d in distro_apt:
                depends_on_apt.append(d)
                depends_on.append(rosdep.to_stack(d))
    print "Depends_on list for stacks: %s"%(', '.join(depends_on))
    if len(depends_on) == 0:
        copy_test_results(workspace, stackbuildspace)
        print "No wet groovy stacks in apt depend on this stack. Test finished here"
        return

    # install depends_on stacks from source
    rosinstall = yaml.dump([{'git': {'local-name': stack, 'uri': distro._repoinfo[stack].url, 'version': 'master'}} for stack in depends_on], default_style=False)
    print "Rosinstall for depends_on:\n %s"%rosinstall
    with open(workspace+"/depends_on.rosinstall", 'w') as f:
        f.write(rosinstall)
    print "Create rosinstall file for depends on"
    call("rosinstall --catkin %s %s/depends_on.rosinstall"%(sourcespace, workspace))

    # install all stack and system dependencies of the depends_on list
    print "Install all dependencies of the depends_on list"
    res = []
    for s in depends_on:
        dep = get_dependencies(os.path.join(sourcespace, s))
        for d in dep:
            if not d in res:
                res.append(d)

    res_apt = []
    for d_apt in [rosdep.to_apt(d) for d in res]:
        if not d_apt in stacks_apt and not d_apt in depends_on_apt:
            res_apt.append(d_apt)
    print "Dependencies of depends_on list are %s"%(', '.join(res_apt))
    if len(res_apt) > 0:
        call("apt-get install --yes %s"%(' '.join(res_apt)))


    # replace the CMakeLists.txt file again
    print "Removing the CMakeLists.txt file generated by rosinstall"
    os.remove(os.path.join(sourcespace, 'CMakeLists.txt'))
    os.makedirs(dependbuildspace)
    os.chdir(dependbuildspace)
    print "Create a new CMakeLists.txt file using catkin"
    call("catkin_init_workspace %s"%sourcespace, ros_env)
    call("cmake ..", ros_env)        
    ros_env = get_ros_env(os.path.join(dependbuildspace, 'buildspace/setup.bash'))

    # build stacks
    print "Build depends-on stacks"
    call("make", ros_env)
    print "Test depends-on stacks"
    call("make run_tests", ros_env)
    copy_test_results(workspace, dependbuildspace)
    print "right here"

if __name__ == '__main__':
    # global try
    try:
        main()
        print "Prerelease script finished cleanly"

    # global catch
    except BuildException as ex:
        print ex.msg

    except Exception as ex:
        print "Prerelease Test Failed. Check out the console output above for details."
        raise ex
